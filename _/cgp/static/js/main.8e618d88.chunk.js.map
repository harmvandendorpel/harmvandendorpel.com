{"version":3,"sources":["svg/stripes.svg","svg/split.svg","svg/stroke.svg","svg/question.svg","svg/crooked.svg","svg/ab.svg","svg/margin.svg","svg/shift.svg","svg/for.svg","svg/plus1.svg","svg/plus2.svg","svg/plus3.svg","svg/min1.svg","svg/min2.svg","svg/min3.svg","svg/fill.svg","utils.ts","color.ts","CGP.ts","canvas.ts","CharacterNode.ts","Parser.ts","ColorBullet.ts","Graph.ts","App.tsx","index.tsx"],"names":["module","exports","__webpack_require__","p","sleep","_x","_sleep","apply","this","arguments","_callee","delay","regenerator_default","a","wrap","_context","prev","next","abrupt","Promise","resolve","setTimeout","stop","viewport","_window$document$docu","window","document","documentElement","width","clientWidth","height","clientHeight","CHANNEL_ALPHA","randomChannelAddress","Math","random","DIMENSIONS","memory","randomColorArray","dim","color","d","toCSSRGB","rgbArray","concat","dimmedGradient","svg","direction","dimmedColor","gradient","at","from","to","layers","layerSize","colors","MEMORY_VALUE_MAX","availableCommands","chances","_chances","Object","defineProperty","weightedCommands","reduce","result","current","frequency","i","push","randomVariableAddress","randomPalette","size","func","Array","map","randomNodeIndex","layer","firstNode","floor","createRandomNode","command","sample","Error","last","randomNext","variables","createRandomGrid","nodes","createRandomMemory","palette","MARGIN_LINE","rect","state","fillColor","strokeColor","rounding","gradientDirection","bb","margin","rectangle","toFixed","move","attr","fill","stroke","fill-opacity","smallestDimension","min","roundingNormalized","radius","rhomb","strokeOnly","midX","midY","polygon","triangle","shapeDirection","circle","showAsSquare","CharacterMapping","_CharacterMapping","ab","forLoop","split","crooked","stripes","shift","question","plus1","min1","plus2","min2","plus3","min3","CharacterNode","x","y","parent","node","classCallCheck","element","traversed","_opacity","createElement","character","length","innerHTML","className","style","left","top","appendChild","opacity","newOpacity","max","value","index","round","Parser","grid","drawingSize","onBeat","aborted","address","amount","registerIndex","newValue","channelAddress","takeFirst","count","console","log","continueIndex","traverseOrder","newState","drawNode","takeCenter","centerBB","currentColor","nextState","lineDistance","line","objectSpread","lookupValues","decodeSplit","scale","offset","newWidth","firstLargest","firstLargestValue","nextIndex","incrementMemory","drawLines","drawWindow","initialState","ColorBullet","container","backgroundColor","Graph","_this","characterGrid","intervalId","interval","characterNode","fade","updatePalette","update","touch","draw","setInterval","clearInterval","firstChild","removeChild","_this2","forEach","v","translate","_this3","dimensions","NODE_WIDTH","createPalette","App","containerElement","graphContainer","parser","graph","run","SVG","makeDrawing","handleKey","e","which","mutate","download","refresh","svgData","svgBlob","Blob","type","svgUrl","URL","createObjectURL","downloadLink","href","Date","now","body","click","initGraph","clear","abort","release","addEventListener","removeEventListener","react_default","id","ref","Component","ReactDOM","render","App_App","getElementById"],"mappings":"sFAAAA,EAAAC,QAAiBC,EAAAC,EAAuB,qDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,mDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,oDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,sDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,qDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,gDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,oDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,mDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,iDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,mDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,mDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,mDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,kDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,kDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,kDCAxCH,EAAAC,QAAiBC,EAAAC,EAAuB,8RCKjC,SAAeC,EAAtBC,GAAA,OAAAC,EAAAC,MAAAC,KAAAC,sDAAO,SAAAC,EAAqBC,GAArB,OAAAC,EAAAC,EAAAC,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAAAF,EAAAG,OAAA,SACE,IAAIC,QAAQ,SAAAC,GACjBC,WAAWD,EAAST,MAFjB,wBAAAI,EAAAO,SAAAZ,6BAMA,SAASa,IACd,IADkCC,EAEIC,OAAOC,SAASC,gBACtD,MAAO,CACLC,MAHY,EADoBJ,EAE1BK,YAGNC,OAJY,EADoBN,EAEbO,cAOhB,aCbMC,EAAgB,EAEhBC,EAAuB,kBAAcC,KAAKC,UAAYC,EAAWC,OAAS,IAAM,GAChFC,EAAmB,iBAAmB,CACjDL,IACAA,IACAA,IACAA,MAGWM,EAAM,SAACC,EAAaC,GAAd,MAAiC,CAACD,EAAM,GAAKC,EAAGD,EAAM,GAAKC,EAAGD,EAAM,GAAKC,EAAGD,EAAM,KACxFE,EAAW,SAACC,GAAD,aAAAC,OACfD,EAAS,IAAM,EADA,KAAAC,OACKD,EAAS,IAAM,EADpB,KAAAC,OACyBD,EAAS,IAAM,EADxC,MAWjB,SAASE,EAAeL,EAAaM,EAASC,GACnD,IAAMC,EAAoBT,EAAIC,EAAO,KACrC,OAAOM,EAAIG,SAAS,SAAU,SAAS3B,GACrCA,EAAK4B,GAAG,EAAeR,EAAZK,EAAqBC,EAAwBR,IACxDlB,EAAK4B,GAAG,EAAwCR,EAApCK,EAA6CP,EAAxBQ,MAChCG,KAAK,EAAG,GAAGC,GAAG,EAAG,GCnBf,IAAMhB,EAA2B,CACtCiB,OAAQ,GACRC,UAAW,GACXjB,OAAQ,GACRkB,OAAQ,GAGGC,EAAmB,IA+FnBC,EAA0B,CAzBlB,KACG,MACE,OACE,QAGD,QAFC,UAGE,SACA,SAGD,SAFA,SACA,SAEC,SAPE,QASE,WADD,WAEI,QAEO,aACI,aAEA,aAEA,aAHA,aAEA,aAEA,cA4B1CC,GAAOC,EAAA,GAAAC,OAAAC,EAAA,EAAAD,CAAAD,EAnDQ,KAoDbxB,iBAAO,KADFyB,OAAAC,EAAA,EAAAD,CAAAD,EAlDW,MAoDfxB,iBAAO,KAFHyB,OAAAC,EAAA,EAAAD,CAAAD,EAjDa,OAoDhBxB,iBAAO,KAHJyB,OAAAC,EAAA,EAAAD,CAAAD,EA7Cc,QAiDhBxB,iBAAO,KAJLyB,OAAAC,EAAA,EAAAD,CAAAD,EAhDe,QAqDjBxB,iBAAO,KALLyB,OAAAC,EAAA,EAAAD,CAAAD,EA/Ce,UAqDjBxB,iBAAO,KANLyB,OAAAC,EAAA,EAAAD,CAAAD,EA9CmB,QAqDrBxB,iBAAO,KAPLyB,OAAAC,EAAA,EAAAD,CAAAD,EA5CiB,SAoDlBxB,iBAAO,KARNyB,OAAAC,EAAA,EAAAD,CAAAD,EA3CiB,SAoDlBxB,iBAAO,KATNyB,OAAAC,EAAA,EAAAD,CAAAD,EAxCgB,SAkDjBxB,iBAAO,KAVNyB,OAAAC,EAAA,EAAAD,CAAAD,EAvCiB,SAkDlBxB,iBAAO,KAXNyB,OAAAC,EAAA,EAAAD,CAAAD,EA1CgB,SAsDjBxB,iBAAO,KAZNyB,OAAAC,EAAA,EAAAD,CAAAD,EAzCgB,SAsDjBxB,iBAAO,IAbNyB,OAAAC,EAAA,EAAAD,CAAAD,EArCqB,WAmDpBxB,iBAAO,KAdRyB,OAAAC,EAAA,EAAAD,CAAAD,EAtCoB,WAqDnBxB,iBAAO,IAfRyB,OAAAC,EAAA,EAAAD,CAAAD,EApCwB,QAoDrBxB,iBAAO,KAhBVyB,OAAAC,EAAA,EAAAD,CAAAD,EAlC+B,aAmDxBxB,iBAAO,KAjBdyB,OAAAC,EAAA,EAAAD,CAAAD,EAjCmC,aAmDtBxB,iBAAO,KAlBpByB,OAAAC,EAAA,EAAAD,CAAAD,EAhCmC,aAmDtBxB,iBAAO,KAnBpByB,OAAAC,EAAA,EAAAD,CAAAD,EA/BmC,aAmDtBxB,iBAAO,KApBpByB,OAAAC,EAAA,EAAAD,CAAAD,EA9BmC,aAmDtBxB,iBAAO,KArBpByB,OAAAC,EAAA,EAAAD,CAAAD,EA7BmC,aAmDtBxB,iBAAO,KAtBpByB,OAAAC,EAAA,EAAAD,CAAAD,EA5BmC,aAmDtBxB,iBAAO,KAvBpBwB,GA0BPG,EAAmBL,EAAkBM,OAAO,SAACC,EAAaC,GAE9D,IADA,IAAMC,EAAmBR,EAAQO,GACxBE,EAAE,EAAGA,EAAID,EAAWC,IAC3BH,EAAOI,KAAKH,GAEd,OAAOD,GACN,IAEGK,EAAwB,kBAAyBlC,iBAAOC,EAAWC,OAAS,IAE5EiC,EAAgB,kBF/JIC,EE+JoBnC,EAAWmB,OF/JlBiB,EE+J0BlC,EF/JgBmC,MAAMlE,MAAM,KAAMkE,MAAMF,IAAOG,IAAIF,GAA3F,IAACD,EAAaC,GEiKjCG,EAAkB,SAACC,GACvB,IAAMC,GAAaD,EAAQ,GAAKxC,EAAWkB,UAE3C,OADepB,KAAK4C,MAAM5C,KAAKC,SAAWC,EAAWkB,WAAauB,GAIpE,SAASE,EAAiBH,GACxB,IAAMI,EAAUC,iBAAOnB,GACvB,IAAKkB,EAAS,MAAM,IAAIE,MAAM,mBAC9B,IAAMC,EAAOP,IAAUxC,EAAWiB,OAAS,EACrC+B,EAAa,kBAAqBD,EAAO,KAAOR,EAAgBC,IAEtE,MAAO,CACLI,UACA/D,KAAM,CACJmE,IACAA,IACAA,KAEFC,UAAW,CACThB,IACAA,IACAA,MA4CC,SAASiB,IAEd,IADA,IAAMC,EAAwB,IAAId,MACzBG,EAAQ,EAAGA,EAAQxC,EAAWiB,OAAQuB,IAC7C,IAAK,IAAIT,EAAI,EAAGA,EAAI/B,EAAWkB,UAAWa,IACxCoB,EAAMpB,EAAIS,EAAQxC,EAAWkB,WAAayB,EAAiBH,GAM/D,MAAO,CAAEW,QAAOlD,OAlBlB,WAEE,IADA,IAAM2B,EAAS,GACNG,EAAI,EAAGA,EAAI/B,EAAWC,OAAQ8B,IACrCH,EAAOG,GAAKhC,iBAAOqB,GAAoB,GAAK,EAE9C,OAAOQ,EAWQwB,GAESC,QADRnB,gBCvPLoB,EAAc,EAGpB,SAASC,EACdC,EACAC,EACAC,EACAhD,EACAiD,EACAC,GACK,IACGC,EAAOL,EAAPK,GAEFC,EAASD,EAAG,GAAKA,EAAG,GAAmB,EAAdP,GAAmBO,EAAG,GAAKA,EAAG,GAAmB,EAAdP,EAChEA,EAAc,EAEVS,EAAYrD,EAAI6C,MACnBM,EAAG,GAAKA,EAAG,GAAc,EAATC,GAAYE,QAAQ,IACpCH,EAAG,GAAKA,EAAG,GAAc,EAATC,GAAYE,QAAQ,IACrCC,MACCJ,EAAG,GAAKC,GAAQE,QAAQ,IACxBH,EAAG,GAAKC,GAAQE,QAAQ,IACzBE,KAAK,CACLC,KAAMV,EAAYhD,EAAegD,EAAW/C,EAAKkD,GAAqB,KACtEQ,OAAQV,EAAcpD,EAASoD,GAAe,KAC9CW,eAAgBZ,GAAaA,EAAU7D,GAAiBwB,GAAkB4C,QAAQ,GAAK,IAIzF,GAAIL,EAAU,CACZ,IAAMW,EAAoBxE,KAAKyE,IAAIV,EAAG,GAAKA,EAAG,GAAIA,EAAG,GAAKA,EAAG,IACvDW,EAAqBb,EAAWvC,EAAmBkD,EAAoB,EAC7EP,EAAUU,OAAOD,IAId,SAASE,EAAMb,EAAOzD,EAAaM,EAASkD,EAA2Be,GAC5E,IAAMC,GAAQf,EAAG,GAAKA,EAAG,IAAM,EAAIA,EAAG,GAChCgB,GAAQhB,EAAG,GAAKA,EAAG,IAAM,EAAIA,EAAG,GAatC,OAZgBnD,EAAIoE,QAAQ,CAC1B,CAACF,EAAMf,EAAG,IACV,CAACA,EAAG,GAAIgB,GACR,CAACD,EAAMf,EAAG,IACV,CAACA,EAAG,GAAIgB,KAEFX,KAAK,CACXC,KAAMQ,EAAa,KAAOlE,EAAeL,EAAOM,EAAKkD,GACrDQ,OAAQ9D,EAASF,GACjBiE,eAAgBM,EAAa,GAAIvE,EAAMR,GAAiBwB,GAAkB4C,QAAQ,KAG7E,EACJH,EAAG,GAAKA,EAAG,IAAM,EAAIA,EAAG,IACxBA,EAAG,GAAKA,EAAG,IAAM,EAAIA,EAAG,IACxBA,EAAG,GAAKA,EAAG,IAAM,EAAI,EAAIA,EAAG,IAC5BA,EAAG,GAAKA,EAAG,IAAM,EAAI,EAAIA,EAAG,IAI1B,SAASkB,EAASvB,EAAaC,EAAiB/C,EAASkD,EAA2BoB,GAA6B,IAC9GnB,EAAOL,EAAPK,GAEQnD,EAAIoE,QAClBE,EAAiB,CACf,CAACnB,EAAG,GAAIA,EAAG,IACX,CAACA,EAAG,GAAIA,EAAG,IACX,CAACA,EAAG,GAAIA,EAAG,KACT,CACF,CAACA,EAAG,GAAIA,EAAG,IACX,CAACA,EAAG,GAAIA,EAAG,IACX,CAACA,EAAG,GAAIA,EAAG,MAIPK,KAAK,CACXC,KAAMV,EAAYhD,EAAegD,EAAW/C,EAAKkD,GAAqB,OAInE,SAASqB,EAAOzB,EAAapD,EAAaM,EAASwE,EAAsBtB,GAAgC,IACtGC,EAAOL,EAAPK,GACFS,EAAoBxE,KAAKyE,IAAIV,EAAG,GAAKA,EAAG,GAAIA,EAAG,GAAKA,EAAG,IACvDC,EAASD,EAAG,GAAKA,EAAG,GAAmB,EAAdP,GAAmBO,EAAG,GAAKA,EAAG,GAAmB,EAAdP,EAChEA,EAAc,EAEVnD,EAAMmE,EAA6B,EAATR,GACjBoB,EACbxE,EAAI6C,KAAKpD,EAAKA,GACdO,EAAIuE,OAAO9E,IAEN8D,KACLJ,EAAG,GAAKC,GAAUD,EAAG,GAAKA,EAAG,GAAKS,GAAqB,EACvDT,EAAG,GAAKC,GAAUD,EAAG,GAAKA,EAAG,GAAKS,GAAqB,GACvDJ,KAAK,CACLC,KAAM1D,EAAeL,EAAOM,EAAKkD,GACjCS,gBAAiBjE,EAAMR,GAAiBwB,GAAkB4C,QAAQ,+TC1DhEmB,IAAgBC,EAAA,GAAA5D,OAAAC,EAAA,EAAAD,CAAA4D,EF8CD,KE7CZC,MADa7D,OAAAC,EAAA,EAAAD,CAAA4D,EF+CE,ME7CdE,MAFY9D,OAAAC,EAAA,EAAAD,CAAA4D,EFgDI,OE7CfjB,MAHW3C,OAAAC,EAAA,EAAAD,CAAA4D,EFiDM,QE7ChBG,KAJU/D,OAAAC,EAAA,EAAAD,CAAA4D,EFkDM,UE7ChBI,MALUhE,OAAAC,EAAA,EAAAD,CAAA4D,EFmDU,QE7CpBK,KANUjE,OAAAC,EAAA,EAAAD,CAAA4D,EFoDK,QE7CfM,MAPUlE,OAAAC,EAAA,EAAAD,CAAA4D,EFqDQ,SE7CjBtB,MARStC,OAAAC,EAAA,EAAAD,CAAA4D,EFsDQ,SE7CjBhB,KATS5C,OAAAC,EAAA,EAAAD,CAAA4D,EFuDO,SE7ChB,UAVS5D,OAAAC,EAAA,EAAAD,CAAA4D,EFwDO,SE7ChB,UAXS5D,OAAAC,EAAA,EAAAD,CAAA4D,EFyDO,SE7ChBO,KAZSnE,OAAAC,EAAA,EAAAD,CAAA4D,EF0DQ,SE7CjB,UAbS5D,OAAAC,EAAA,EAAAD,CAAA4D,EF2DW,WE7ClB,UAdO5D,OAAAC,EAAA,EAAAD,CAAA4D,EF4DY,WE7CnB,QAfO5D,OAAAC,EAAA,EAAAD,CAAA4D,EF6De,QE7CpB,UAhBK5D,OAAAC,EAAA,EAAAD,CAAA4D,EF8DmB,gBE7CrB,UAjBE5D,OAAAC,EAAA,EAAAD,CAAA4D,EF+DsB,aE7CvB,UAlBC5D,OAAAC,EAAA,EAAAD,CAAA4D,EFgE0B,aE7CrBQ,MAnBLpE,OAAAC,EAAA,EAAAD,CAAA4D,EFiE0B,aE7CrBS,MApBLrE,OAAAC,EAAA,EAAAD,CAAA4D,EFkE0B,aE7CrBU,MArBLtE,OAAAC,EAAA,EAAAD,CAAA4D,EFmE0B,aE7CrBW,MAtBLvE,OAAAC,EAAA,EAAAD,CAAA4D,EFoE0B,aE7CrBY,MAvBLxE,OAAAC,EAAA,EAAAD,CAAA4D,EFqE0B,aE7CrBa,MAxBLb,GAsDDc,cA2BnB,SAAAA,EAAYC,EAAUC,EAAUC,EAAuBC,GAAe9E,OAAA+E,EAAA,EAAA/E,CAAApD,KAAA8H,GAAA9H,KAzB9DoI,aAyB6D,EAAApI,KAxB7DqI,eAwB6D,EAAArI,KAvB7DsI,SAAkB,EAwBxBtI,KAAKqI,WAAY,EACjBrI,KAAKoI,QAAUlH,SAASqH,cAAc,OACtC,IAAMC,EAAYzB,GAAiBmB,EAAK1D,SACpCgE,EAAUC,OAAS,EACrBzI,KAAKoI,QAAQM,UAAb,YAAAtG,OAAqCoG,EAArC,OAEAxI,KAAKoI,QAAQM,UAAYF,EAE3BxI,KAAKoI,QAAQO,UAAY,OACzB3I,KAAKoI,QAAQQ,MAAMC,KAAnB,GAAAzG,OAA6B2F,EAA7B,MACA/H,KAAKoI,QAAQQ,MAAME,IAAnB,GAAA1G,OAA4B4F,EAA5B,MACAC,EAAOc,YAAY/I,KAAKoI,SACxBpI,KAAKgJ,QAAUhJ,KAAKsI,4DA5BpB,GAAIR,EAAcrE,UAAYzD,KAA9B,CACA,IAAMiJ,EAA6B,GAAhBjJ,KAAKsI,SACpBtI,KAAKqI,UACPrI,KAAKgJ,QAAUtH,KAAKwH,IAAI,GAAKD,GAE7BjJ,KAAKgJ,QAAUtH,KAAKwH,IAAI,EAAGD,oCAK7BnB,EAAcrE,QAAUzD,KACxBA,KAAKgJ,QAAU,EACfhJ,KAAKqI,WAAY,gCAlBPc,GACVnJ,KAAKsI,SAAWa,EAChBnJ,KAAKoI,QAAQQ,MAAMI,QAAnB,GAAA5G,OAAgCpC,KAAKsI,mBARpBR,GACZrE,eCnDT,IAGM0F,GAAQ,SAACtE,EAA0BuE,EAAcF,GAAzC,OACZxH,KAAK2H,MAAMxE,EAAUuE,GAASpG,EAAmBkG,IAE9BI,cAOnB,SAAAA,EAAYC,EAAejH,EAASkH,EAAsBC,GAAkBrG,OAAA+E,EAAA,EAAA/E,CAAApD,KAAAsJ,GAAAtJ,KAN5E0J,SAAkB,EAMyD1J,KAL3EsC,IAAU,KAKiEtC,KAJ3EwJ,iBAI2E,EAAAxJ,KAH3EuJ,UAG2E,EAAAvJ,KAF3EyJ,YAE2E,EACzEzJ,KAAKuJ,KAAOA,EACZvJ,KAAKsC,IAAMA,EACXtC,KAAKwJ,YAAcA,EACnBxJ,KAAKyJ,OAASA,2DAGH5E,GAA+C,IAClDhD,EAAW7B,KAAKuJ,KAAhB1H,OACR,OAAOgD,EAAUX,IAAI,SAACyF,GAAD,OAA8C9H,EAAO8H,6CAG5DzB,EAAc0B,EAAeC,GAAsB,ILrD/CV,EAAchD,EAAY+C,EKsDpCrH,EAAW7B,KAAKuJ,KAAhB1H,OAEFiI,EADWjI,EAAOqG,EAAKrD,UAAUgF,IACF,EAATD,EAC5B/H,EAAOqG,EAAKrD,UAAUgF,KLzDJV,EKyD4BW,ELzDd3D,EKyDwB,ELzDZ+C,EKyDelG,ELzDOtB,KAAKyE,IAAIzE,KAAKwH,IAAIC,EAAOhD,GAAM+C,yCK4DtFhB,EAAcqB,GAAoB,IACrC1H,EAAoB0H,EAApB1H,OAAQoD,EAAYsE,EAAZtE,QAIhB,OAFqBA,EADAvD,KAAK2H,MAAMxH,EAAOqG,EAAKrD,UAAU,IAAM7B,GAAoBiC,EAAQwD,OAAS,KAErEvE,IAAI,SAAC6F,GAAD,OAA2ClI,EAAOkI,GAAkB/G,EAAmB,kFAIvG6B,EAA0BO,EAAa8C,EAAc8B,sFACjEzH,EAA6B,KAE/BA,EADEsC,EAAU,GAAK7B,EAAmB,EAzCH,aA2CxB6B,EAAU,GAAK7B,EAAmB,EAAI,EA5ClB,WA+CjBoC,EAAMK,GAAG,GAAKL,EAAMK,GAAG,GAAKL,EAAMK,GAAG,GAAKL,EAAMK,GAAG,GA/ClC,WACI,aAiD7BwE,EAAQd,GAAMtE,EAAW,EAAG,GAAK,EACvCqF,QAAQC,IAAIF,GACNG,EAAgBjB,GAAMtE,EAAW,EAAG,GACpCwF,EAAgBxF,EAAU,GAAK7B,EAAmB,WAClDhD,KAAKmH,MAAM5E,EAAW0H,EAAO7E,EAAO8C,EAAM8B,EAAWI,EAAeC,kLAI1E9H,EACA0H,EACA7E,EACA8C,EACA8B,EACAI,EACAC,iFAEMtG,EAjE6B,eAiErBxB,GACX6C,EAAMK,GAAG,GAAKL,EAAMK,GAAG,IAAMwE,GAC7B7E,EAAMK,GAAG,GAAKL,EAAMK,GAAG,IAAMwE,EAEvBtG,EAAI,cAAGA,EAAIsG,uBACZb,EAAQiB,EAAgB1G,EAAIsG,EAAQtG,EAAI,EACxC8B,EAvE2B,eAuElBlD,EAA4B,CACzC6C,EAAMK,GAAG,GAAK1B,EAAOqF,EACrBhE,EAAMK,GAAG,GACTL,EAAMK,GAAG,GAAK1B,GAAQqF,EAAQ,GAC9BhE,EAAMK,GAAG,IAEX,CACEL,EAAMK,GAAG,GACTL,EAAMK,GAAG,GAAK1B,EAAOqF,EACrBhE,EAAMK,GAAG,GACTL,EAAMK,GAAG,GAAK1B,GAAQqF,EAAQ,IAG1BkB,iBAAsBlF,GAAOK,OAEb,OAAlB2E,GAA0BhB,IAAUgB,mCAChCpK,KAAKuK,SAASrC,EAAKzH,KAAK,GAAI6J,mDAE5BtK,KAAKuK,SAASrC,EAAKzH,KAAKuJ,EAAY,EAAIZ,GAAQkB,WApB/B3G,8MAwBZyB,EAAa8C,EAAcsC,EAAoBhF,EAA2Be,kFACnFkE,EAAcnE,EAAMlB,EAAMK,GAAIzF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAOvJ,KAAKsC,IAAKkD,EAAmBe,GAC/FoE,iBAAuBvF,GAAOK,GAAyBgF,aACvDzK,KAAKuK,SAASrC,EAAKzH,KAAK,GAAIkK,gJAG1BvF,EAAapD,EAAa6C,GASlC,IARA,IACMtC,EAAsBsC,EAAU,GAAKA,EAAU,GArGlB,aADJ,WAuGzB+F,EAAe/F,EAAU,GAAK7B,EAFf,IAEkD,EAC/DyC,EAAOL,EAAPK,GACFwE,EAzGyB,aAyGjB1H,GACXkD,EAAG,GAAKA,EAAG,IAAMmF,GAAgB,GACjCnF,EAAG,GAAKA,EAAG,IAAMmF,GAAgB,EAE3BjH,EAAI,EAAGA,EAAIsG,EAAOtG,IAAK,CAC9B,IAAIkH,EAAO,KACX,GA/G6B,aA+GzBtI,EAAwB,CAC1B,IAAMyF,EAAIvC,EAAG,IAAM9B,EAAE,IAAOiH,EAC5BC,EAAO7K,KAAKsC,IAAIuI,KACdpF,EAAG,GACHuC,EACAvC,EAAG,GACHuC,OAEG,CACL,IAAMD,EAAItC,EAAG,IAAM9B,EAAE,IAAOiH,EAC5BC,EAAO7K,KAAKsC,IAAIuI,KACd9C,EACAtC,EAAG,GACHsC,EACAtC,EAAG,IAIPoF,EACG7E,OAAO,CAAE5E,MAAO,KAChB0E,KAAK,CAAEE,OAAQ9D,EAASF,6EAIlB0D,EAAewC,EAAc9C,gFAClCuF,EACJvF,EAAMK,GAAG,GAAKC,EAASN,EAAMK,GAAG,GAAKC,GACrCN,EAAMK,GAAG,GAAKC,EAASN,EAAMK,GAAG,GAAKC,EAFftC,OAAA0H,EAAA,EAAA1H,CAAA,GAKjBgC,EALiB,CAMpBK,GAAI,CACFL,EAAMK,GAAG,GAAKC,EACdN,EAAMK,GAAG,GAAKC,EACdN,EAAMK,GAAG,GAAKC,EACdN,EAAMK,GAAG,GAAKC,KAGlBN,WAEIpF,KAAKuK,SAASrC,EAAKzH,KAAK,GAAIkK,mLAGrBvB,EAAuBhE,gHACtB,OAAVgE,IAAkBpJ,KAAK0J,yEAIrB9J,EAAM,UACJmF,EAAU/E,KAAKuJ,KAAfxE,MACFmD,EAAOnD,EAAMqE,GAEX3I,EAAkByH,EAAlBzH,KAAM+D,EAAY0D,EAAZ1D,QACRK,EAAY7E,KAAK+K,aAAa7C,EAAKrD,WAEzC7E,KAAKyJ,OAAOL,EAAOlB,EAAMrD,QACjBL,SH9GyB,kBAZT,kBAFJ,gBAKG,kBANN,eAWQ,mBAMe,uBAVd,mBAOI,qBAIc,uBACA,uBACA,uBACA,uBACA,uBACA,uBAlBhB,kBAHN,iBAMI,mBAIA,mBAHD,oBALD,qBAMC,oBAGI,yDGkHnBxE,KAAKuK,SAAS9J,EAAK,GAAI2E,4BACvBpF,KAAKuK,SAAS9J,EAAK,GAAI2E,iEAIvBpF,KAAKgL,YAAYnG,EAAWO,EAAO8C,GAAM,iEAIzClI,KAAKgL,YAAYnG,EAAWO,EAAO8C,GAAM,uDAIzC+C,EAAQpG,EAAU,GAAK7B,EACvB6C,EAAOhB,EAAU,GAAK7B,EACpByC,EAAOL,EAAPK,GAEFrE,EAASqE,EAAG,GAAKA,EAAG,GAGpByF,EAASrF,GADIzE,GADb+J,EAAW/J,EAAQ6J,IAInBX,iBACDlF,GACHK,GAAI,CACFA,EAAG,GAAKyF,EACRzF,EAAG,GACHA,EAAG,GAAK0F,EAAWD,EACnBzF,EAAG,gBAGDzF,KAAKuK,SAAS9J,EAAK,GAAI6J,uDAKrB7E,EAAOL,EAAPK,GACFrE,GAASqE,EAAG,GAAKA,EAAG,IAAM,EAC1BnE,GAAUmE,EAAG,GAAKA,EAAG,IAAM,EAE3BlD,EAAYsC,EAAU,GAAK,cAC3B7E,KAAKuK,SAAS9J,EAAK8B,EAAY,EAAI,GAAnCa,OAAA0H,EAAA,EAAA1H,CAAA,GAA4CgC,EAA5C,CAAmDK,GAAI,CAACA,EAAG,GAAIA,EAAG,GAAIA,EAAG,GAAKrE,EAAOqE,EAAG,GAAKnE,+BAC7FtB,KAAKuK,SAAS9J,EAAK8B,EAAY,EAAI,GAAnCa,OAAA0H,EAAA,EAAA1H,CAAA,GAA4CgC,EAA5C,CAAmDK,GAAI,CAACA,EAAG,GAAKrE,EAAOqE,EAAG,GAAIA,EAAG,GAAa,EAARrE,EAAWqE,EAAG,GAAKnE,+BACzGtB,KAAKuK,SAAS9J,EAAK8B,EAAY,EAAI,GAAnCa,OAAA0H,EAAA,EAAA1H,CAAA,GAA4CgC,EAA5C,CAAmDK,GAAI,CAACA,EAAG,GAAIA,EAAG,GAAKnE,EAAQmE,EAAG,GAAKrE,EAAOqE,EAAG,GAAc,EAATnE,+BACtGtB,KAAKuK,SAAS9J,EAAK8B,EAAY,EAAI,GAAnCa,OAAA0H,EAAA,EAAA1H,CAAA,GAA4CgC,EAA5C,CAAmDK,GAAI,CAACA,EAAG,GAAKrE,EAAOqE,EAAG,GAAKnE,EAAQmE,EAAG,GAAa,EAARrE,EAAWqE,EAAG,GAAc,EAATnE,0DAMlH8J,EAAevG,EAAU,GAAKA,EAAU,GAAK,EAAI,EACjDwG,EAAoBxG,EAAUuG,GAC9BE,EAAYzG,EAAU,GAAKwG,EAAoB,EAAID,YACnDpL,KAAKuK,SAAS9J,EAAK6K,GAAYlG,qDAKjCP,EAAU,GAAKA,EAAU,sCACrB7E,KAAKuK,SAAS9J,EAAK,GAAI2E,iEAKzBpF,KAAK0F,OFjRS,GEiRYwC,EAAM9C,iEAKhCpF,KAAKuK,SAAS9J,EAAK,GAAI2E,uDAI7BpF,KAAKuL,gBAAgBrD,EAAM,EAAG,aACxBlI,KAAKuK,SAAS9J,EAAK,GAAI2E,uDAI7BpF,KAAKuL,gBAAgBrD,GAAO,EAAG,aACzBlI,KAAKuK,SAAS9J,EAAK,GAAI2E,uDAI7BpF,KAAKuL,gBAAgBrD,EAAM,EAAG,aACxBlI,KAAKuK,SAAS9J,EAAK,GAAI2E,uDAI7BpF,KAAKuL,gBAAgBrD,GAAO,EAAG,aACzBlI,KAAKuK,SAAS9J,EAAK,GAAI2E,uDAI7BpF,KAAKuL,gBAAgBrD,EAAM,EAAG,aACxBlI,KAAKuK,SAAS9J,EAAK,GAAI2E,uDAI/BpF,KAAKuL,gBAAgBrD,GAAO,EAAG,aACvBlI,KAAKuK,SAAS9J,EAAK,GAAI2E,uDAI7BpF,KAAKwL,UAAUpG,EAAOpF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAO1E,aACpD7E,KAAK0F,OAAOR,EAAagD,EAAM9C,uDAIrCD,EAAKC,EAAOpF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAO,KAAMvJ,KAAKsC,IAAK,KAAMuC,EAAU,GAAK7B,EAAmB,aAClGhD,KAAK0F,OAAOR,EAAagD,EAAM9C,uDAIrCD,EAAKC,EAAO,KAAMpF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAOvJ,KAAKsC,IAAK,KAAMuC,EAAU,GAAK7B,EAAmB,aAClGhD,KAAK0F,OAAOR,EAAagD,EAAM9C,uDAIrCyB,EAAOzB,EAAOpF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAOvJ,KAAKsC,KAAK,EAAOuC,EAAU,GAAK7B,EAAmB,cAC/FhD,KAAK0F,OAAOR,EAAagD,EAAM9C,yDAIrCyB,EAAOzB,EAAOpF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAOvJ,KAAKsC,KAAK,EAAMuC,EAAU,GAAK7B,EAAmB,cAC9FhD,KAAK0F,OAAOR,EAAagD,EAAM9C,yDAIrCD,EAAKC,EAAOpF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAO,KAAMvJ,KAAKsC,IAAKuC,EAAU,GAAIA,EAAU,GAAK7B,EAAmB,cAC1GhD,KAAK0F,OAAOR,EAAagD,EAAM9C,oEAI/BpF,KAAKyL,WACTrG,EACA8C,EACArD,EAAU,GAAK7B,EAAmB,EAClC6B,EAAU,GAAK7B,EAAmB,EAClC6B,EAAU,GAAK7B,EAAmB,yDAKpC2D,EAASvB,EAAOpF,KAAK0K,aAAaxC,EAAMlI,KAAKuJ,MAAOvJ,KAAKsC,IAAKuC,EAAU,GAAK,IAAKA,EAAU,GAAK7B,EAAmB,cAC9GhD,KAAK0F,OAAOR,EAAagD,EAAM9C,kDAIrC8E,QAAQC,IAAR,wBAAA/H,OAAoCoC,4PAKpCxE,KAAK0J,gEACHgC,EAAqB,CACzBjG,GAAI,CAAC,EAAG,EAAGzF,KAAKwJ,YAAYpI,MAAOpB,KAAKwJ,YAAYlI,SAGtD4I,QAAQC,IAAI,qBACNnK,KAAKuK,SAAS,EAAGmB,UACvB5D,GAAcrE,QAAU,KACxByG,QAAQC,IAAI,2IAIZnK,KAAK0J,SAAU,WC9XEiC,cAGnB,SAAAA,EAAY5D,EAAU6D,GAA2BxI,OAAA+E,EAAA,EAAA/E,CAAApD,KAAA2L,GAAA3L,KAFzCoI,aAEwC,EAC9C,IAAMA,EAAUlH,SAASqH,cAAc,OAEvCH,EAAQQ,MAAMC,KAAd,GAAAzG,OAAwB2F,EAAxB,MACAK,EAAQO,UAAY,QACpBiD,EAAU7C,YAAYX,GACtBpI,KAAKoI,QAAUA,kDAGPe,GACRnJ,KAAKoI,QAAQQ,MAAMiD,gBAAkB3J,EAASiH,YCC7B2C,cAOnB,SAAAA,EAAYF,EAA0BrC,GAAc,IAAAwC,EAAA/L,KAAAoD,OAAA+E,EAAA,EAAA/E,CAAApD,KAAA8L,GAAA9L,KAN5C4L,eAM4C,EAAA5L,KAL5CuJ,UAK4C,EAAAvJ,KAJ5CgM,cAAsC,KAIMhM,KAH5CiF,QAA8B,GAGcjF,KAF5CiM,gBAE4C,EAAAjM,KAmEpDkM,SAAW,WACT,GAAKH,EAAKC,cAAV,CACA,IAAK,IAAIrI,EAAI,EAAGA,EAAIoI,EAAKC,cAAcvD,OAAQ9E,IAAK,CAClD,IAAMwI,EAA8BJ,EAAKC,cAAcrI,GAClDwI,GACLA,EAAcC,OAGhBL,EAAKM,kBA3E6CrM,KA8EpDsM,OAAS,SAAClD,EAAuBlB,EAAcrD,GAC/B,OAAVuE,IACC2C,EAAKC,eAC0BD,EAAKC,cAAc5C,GACzCmD,UAjFdvM,KAAK4L,UAAYA,EACjB5L,KAAKuJ,KAAOA,EACZvJ,KAAKwM,OAELxM,KAAKiM,WAAaQ,YAAYzM,KAAKkM,SAAU,0DAM7C,IAFAQ,cAAc1M,KAAKiM,YAEZjM,KAAK4L,UAAUe,YACpB3M,KAAK4L,UAAUgB,YAAY5M,KAAK4L,UAAUe,oDAI9B,IAAAE,EAAA7M,KACN6B,EAAW7B,KAAKuJ,KAAhB1H,OACR7B,KAAKuJ,KAAKtE,QAAQ6H,QAAQ,SAAC9K,EAAOoH,GAChC,IAAM5F,EAAexB,EAAMkC,IAAI,SAAC6F,GAAD,OAA2ClI,EAAOkI,GAAkB/G,EAAmB,MACtH6J,EAAK5H,QAAQmE,GAAOpH,MAAQwB,4CAU9B,IALA,IAAMuJ,EAAIhM,IACJyC,EAA4B,GAG5BwJ,GAAaD,EAAE3L,MAAQ2L,EAAEzL,OAFf,GAEwBM,EAAWmB,QAAoB,EAC9DY,EAAI,EAAGA,EAAI/B,EAAWmB,OAAQY,IACrCH,EAAOG,GAAK,IAAIgI,GAJF,GAIchI,EAAcqJ,EAAWhN,KAAK4L,WAE5D,OAAOpI,iCAGF,IAAAyJ,EAAAjN,KACC+M,EAAIhM,IACJmM,EAAa,CAhDJ,GAiDAtL,EAAWkB,UAhDV,GAiDAlB,EAAWiB,QAErBmK,EAAY,EACdD,EAAE3L,MAAQ2L,EAAEzL,OAAU4L,EAAW,IAAK,GACvCH,EAAEzL,OAAS4L,EAAW,IAAK,GAG9BlN,KAAKgM,cAAgBhM,KAAKuJ,KAAKxE,MAAMxB,OAAO,SAACC,EAAsB0E,EAAckB,GAC/E,IAAMrB,EAAIqB,EAAQxH,EAAWkB,UACvBkF,EAAItG,KAAK4C,MAAM8E,EAAQxH,EAAWkB,WAExC,GAAU,IAANkF,GAAWD,EAAI,EACjB,OAAOvE,EAGT,IAAMqF,EAAiB,IAAVO,EACT8D,EAAW,GAAK,EAAIF,EAAU,GAAKG,GAlE1B,GAmETpF,EAAiBiF,EAAU,GAEzBlE,EApEQ,GAoEFd,EAAkBgF,EAAU,GAGxC,OADAxJ,EAAO4F,GAAS,IAAItB,GAAce,EAAMC,EAAKmE,EAAKrB,UAAW1D,GACtD1E,GACN,IACHxD,KAAKiF,QAAUjF,KAAKoN,yBC/EHC,8MACXC,iBAA0C,OAC1CC,eAAwC,OACxCjL,aACAiH,KAAgBzE,MAChB0I,OAAwB,OACxBC,MAAsB,OAwB9BC,IAAM,SAACJ,GACAA,IAAoBvB,EAAKuB,mBAC9BvB,EAAKuB,iBAAmBA,EACxBvB,EAAKzJ,IAAMqL,IAAIL,GACfvB,EAAK6B,YAAY7B,EAAKxC,UAqBxBsE,UAAY,SAACC,GACX,OAAQA,EAAEC,OACR,KAAK,GACHhC,EAAKiC,SACL,MAEF,KAAK,GACHjC,EAAKkC,WACL,MACF,KAAK,GACHlC,EAAKmC,UACL,MACF,QACEhE,QAAQC,IAAI2D,EAAEC,WAWpBE,SAAW,WACT,GAAKlC,EAAKuB,iBAAV,CACA,IAAMa,EAAUpC,EAAKuB,iBAAiB5E,UAChC0F,EAAU,IAAIC,KAAK,CAACF,GAAU,CAACG,KAAK,gCACpCC,EAASC,IAAIC,gBAAgBL,GAC7BM,EAAexN,SAASqH,cAAc,KAC5CmG,EAAaC,KAAOJ,EACpBG,EAAaT,SAAb,OAAA7L,OAA+BwM,KAAKC,MAApC,QACA3N,SAAS4N,KAAK/F,YAAY2F,GAC1BA,EAAaK,QACb7N,SAAS4N,KAAKlC,YAAY8B,OAG5BM,UAAY,SAACpD,GACPG,EAAK0B,QACT1B,EAAKwB,eAAiB3B,EACtBG,EAAK0B,MAAQ,IAAI3B,GAAMC,EAAKwB,eAAgBxB,EAAKxC,+FAtFjD,OAAO,8EAGSA,8EACVwD,EAAIhM,IACLf,KAAKuJ,yDACJC,EAAc,CAAEpI,MAAO2L,EAAEzL,OAAQA,OAAQyL,EAAEzL,QACjDtB,KAAKsC,IAAIyB,KAAKgJ,EAAEzL,OAAQyL,EAAEzL,QAC1BtB,KAAKsC,IAAI2M,QAELjP,KAAKwN,QACPxN,KAAKwN,OAAO0B,QAGTlP,KAAKyN,4BAAa,IAAI/I,MAAM,uCACjC1E,KAAKwN,OAAS,IAAIlE,GAAOC,EAAMvJ,KAAKsC,IAAKkH,EAAaxJ,KAAKyN,MAAMnB,kBAC3DtM,KAAKwN,OAAOhB,gCACZ5M,EAAM,aACZI,KAAKkO,+IAWL,GAAIlO,KAAKuJ,KAAM,CACb,IAAK,IAAI5F,EAAI,EAAGA,EAAI,GAAIA,IACf3D,KAAKuJ,KAEdvJ,KAAK4N,YAAY5N,KAAKuJ,yCAKxB,IAAKvJ,KAAKyN,MAAO,MAAM,IAAI/I,MAAM,wBACjC,IAAK1E,KAAKuN,eAAgB,MAAM,IAAI7I,MAAM,+BAC1C1E,KAAKuJ,KAAOzE,IACZ9E,KAAKyN,MAAM0B,UACXnP,KAAKyN,MAAQ,IAAI3B,GAAM9L,KAAKuN,eAAgBvN,KAAKuJ,MACjDvJ,KAAK4N,YAAY5N,KAAKuJ,kDAqBtBrI,SAASkO,iBAAiB,UAAWpP,KAAK6N,WAAW,kDAGrD3M,SAASmO,oBAAoB,UAAWrP,KAAK6N,WAAW,oCAuBxD,OACEyB,EAAAjP,EAAAkI,cAAA,OAAKI,UAAU,OACb2G,EAAAjP,EAAAkI,cAAA,OAAKgH,GAAG,UAAUC,IAAKxP,KAAKgP,YAC5BM,EAAAjP,EAAAkI,cAAA,OAAKgH,GAAG,UAAUC,IAAKxP,KAAK0N,cAtGH+B,aCHjCC,IAASC,OAAOL,EAAAjP,EAAAkI,cAACqH,GAAD,MAAS1O,SAAS2O,eAAe","file":"static/js/main.8e618d88.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/stripes.105b88c3.svg\";","module.exports = __webpack_public_path__ + \"static/media/split.af729364.svg\";","module.exports = __webpack_public_path__ + \"static/media/stroke.740e1a00.svg\";","module.exports = __webpack_public_path__ + \"static/media/question.8a834d4f.svg\";","module.exports = __webpack_public_path__ + \"static/media/crooked.a6856264.svg\";","module.exports = __webpack_public_path__ + \"static/media/ab.bf68e8e1.svg\";","module.exports = __webpack_public_path__ + \"static/media/margin.17e01921.svg\";","module.exports = __webpack_public_path__ + \"static/media/shift.76e584a1.svg\";","module.exports = __webpack_public_path__ + \"static/media/for.5c8ea225.svg\";","module.exports = __webpack_public_path__ + \"static/media/plus1.86cbb397.svg\";","module.exports = __webpack_public_path__ + \"static/media/plus2.0d34c00a.svg\";","module.exports = __webpack_public_path__ + \"static/media/plus3.113787b5.svg\";","module.exports = __webpack_public_path__ + \"static/media/min1.3ffd31cb.svg\";","module.exports = __webpack_public_path__ + \"static/media/min2.a1f28303.svg\";","module.exports = __webpack_public_path__ + \"static/media/min3.3f03d502.svg\";","module.exports = __webpack_public_path__ + \"static/media/fill.13fcfa13.svg\";","export type Viewport = {\n  width: number,\n  height: number\n}\n\nexport async function sleep(delay: number):Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay)\n  })\n}\n\nexport function viewport():Viewport {\n  const ratio = 1 // window.devicePixelRatio,\n  const { clientWidth, clientHeight } = window.document.documentElement\n  return {\n    width: clientWidth * ratio,\n    height: clientHeight * ratio\n  }\n}\n\nexport const initArray = (size:number, func: (item:any, index:number) => any) => Array.apply(null, Array(size)).map(func)\n\nexport const bound = (value:number, min:number, max:number):number => Math.min(Math.max(value, min), max)","import { DIMENSIONS } from './CGP'\n\nexport type ChannelAddress = number\nexport type Channel = number\nexport type Color = [Channel, Channel, Channel, Channel]\nexport type ColorPointer = [ChannelAddress, ChannelAddress, ChannelAddress, ChannelAddress]\nexport type Palette = Array<ColorPointer>\nexport const CHANNEL_ALPHA = 3\n\nexport const randomChannelAddress = ():Channel => Math.random() * (DIMENSIONS.memory - 1) << 0\nexport const randomColorArray = ():ColorPointer => [\n  randomChannelAddress(),\n  randomChannelAddress(),\n  randomChannelAddress(),\n  randomChannelAddress()\n]\n\nexport const dim = (color:Color, d:number):Color => [color[0] * d, color[1] * d, color[2] * d, color[3]]\nexport const toCSSRGB = (rgbArray:Color) =>\n  `rgb(${rgbArray[0] << 0},${rgbArray[1] << 0},${rgbArray[2] << 0})`\n\n// export const multiplyChannel = (color:Color, channelIndex:number, factor:number):Color => {\n//   const result:any = color.map((channel:Channel, index:number) =>\n//     (index === channelIndex) ? Math.min(255, channel * factor) : channel\n//   )\n\n//   return result\n// }\n\nexport function dimmedGradient(color:Color, svg:any, direction:boolean):any {\n  const dimmedColor:Color = dim(color, 0.85)\n  return svg.gradient('linear', function(stop:any) {\n    stop.at(0, direction ? toCSSRGB(dimmedColor) : toCSSRGB(color))\n    stop.at(1, !direction ? toCSSRGB(dimmedColor) : toCSSRGB(color))\n  }).from(0, 0).to(0, 1)\n}\n","import { initArray } from './utils'\nimport { sample, random } from 'lodash'\nimport { Palette, randomColorArray } from './color'\n\nexport type CGPNodeAddress = number | null\nexport type CGPVariableAddress = number\nexport type VariableValue = number \n\ntype CGPDimensions = {\n  layers: number,\n  layerSize: number,\n  memory: number,\n  colors: number,\n}\n\nexport const DIMENSIONS:CGPDimensions = {\n  layers: 30,\n  layerSize: 12,\n  memory: 32,\n  colors: 7,\n}\n\nexport const MEMORY_VALUE_MAX = 255\n\ntype CGPNextNodes = [CGPNodeAddress, CGPNodeAddress, CGPNodeAddress]\nexport type CGPVariableAddresses = [CGPVariableAddress, CGPVariableAddress, CGPVariableAddress]\nexport type VariableValues = [VariableValue, VariableValue, VariableValue]\n\ntype Split = string\ntype For = string\ntype Fill = string\ntype Stroke = string\ntype Crook = string\ntype Margin = string\ntype Triangle = string\ntype Increment1 = string\ntype Decrement1 = string\ntype Increment2 = string\ntype Decrement2 = string\ntype Increment3 = string\ntype Decrement3 = string\ntype DottedLine = string\ntype SamePlace = string\ntype Circle = string\ntype Switch = string\ntype TerminateWhen = string\ntype Square = string\ntype AB = string\ntype Shift = string\ntype Window = string\ntype Multiply = string\n\ntype CommandId =\n  Split |\n  Margin |\n  Fill |\n  Crook |\n  Circle |\n  For | \n  Multiply |\n  Stroke | \n  Increment1 |\n  Decrement1 |\n  Increment2 |\n  Decrement2 |\n  Increment3 |\n  Decrement3 |\n  SamePlace |\n  TerminateWhen |\n  Triangle |\n  Switch |\n  DottedLine |\n  Square |\n  AB |\n  Shift |\n  Window\n\ntype List = Array<CommandId>\n\nexport type CGPNode = {\n  command: CommandId,\n  next: CGPNextNodes,\n  variables: CGPVariableAddresses,\n}\n\nexport type Memory = Array<VariableValue>\nexport type CGPGrid = {\n  nodes: Array<CGPNode>,\n  memory: Memory,\n  palette: Palette,\n}\n\nexport const AB:AB = 'ab'\nexport const FOR: For = 'for'\nexport const FILL: Fill = 'fill'\nexport const SPLIT: Split = 'split'\nexport const CROOK: Crook = 'crooked'\nexport const LINES: SamePlace = 'lines'\nexport const SHIFT:Shift = 'shift'\nexport const MARGIN: Margin = 'margin'\nexport const STROKE: Stroke = 'stroke'\nexport const SQUARE:Square = 'square'\nexport const WINDOW:Window = 'window'\nexport const SWITCH:Switch = 'switch'\nexport const CIRCLE: Circle = 'circle'\nexport const TRIANGLE:Triangle = 'triangle'\nexport const MULTIPLY: Multiply = 'multiply'\nexport const SAME_PLACE: SamePlace = 'same!'\nexport const DOTTED_STROKE: DottedLine = 'dotted stroke'\nexport const TERMINATE_WHEN:TerminateWhen = 'terminate?'\nexport const INCREMENT_REGISTER_1: Increment1 = 'increment1'\nexport const DECREMENT_REGISTER_1: Decrement1 = 'decrement1'\nexport const INCREMENT_REGISTER_2: Increment2 = 'increment2'\nexport const DECREMENT_REGISTER_2: Decrement2 = 'decrement2'\nexport const INCREMENT_REGISTER_3: Increment3 = 'increment3'\nexport const DECREMENT_REGISTER_3: Decrement3 = 'decrement3'\n\nexport const availableCommands: List = [\n  AB,\n  FOR,\n  FILL,\n  SPLIT,\n  SHIFT,\n  CROOK,\n  MARGIN,\n  STROKE,\n  SWITCH,\n  SQUARE,\n  WINDOW,\n  CIRCLE,\n  LINES,\n  MULTIPLY,\n  TRIANGLE,\n  SAME_PLACE, \n  TERMINATE_WHEN,\n  INCREMENT_REGISTER_1,\n  INCREMENT_REGISTER_2,\n  INCREMENT_REGISTER_3,\n  DECREMENT_REGISTER_1,\n  DECREMENT_REGISTER_2,\n  DECREMENT_REGISTER_3,\n]\n\nconst chances = {\n  [AB]: random(50),\n  [FOR]: random(50),\n  [FILL]: random(50),\n  [SHIFT]: random(50),\n  [SPLIT]: random(50),\n  [CROOK]: random(50),\n  [LINES]: random(30),\n  [MARGIN]: random(50),\n  [STROKE]: random(50),\n  [SWITCH]: random(50),\n  [CIRCLE]: random(25),\n  [SQUARE]: random(50),\n  [WINDOW]: random(3),\n  [MULTIPLY]: random(50),\n  [TRIANGLE]: random(2),\n  [SAME_PLACE]: random(50),\n  [TERMINATE_WHEN]: random(20),\n  [INCREMENT_REGISTER_1]: random(50),\n  [DECREMENT_REGISTER_1]: random(50),\n  [INCREMENT_REGISTER_2]: random(50),\n  [DECREMENT_REGISTER_2]: random(50),\n  [INCREMENT_REGISTER_3]: random(50),\n  [DECREMENT_REGISTER_3]: random(50),\n}\n\nconst weightedCommands = availableCommands.reduce((result:List, current:CommandId):List => {\n  const frequency:number = chances[current]\n  for (let i=0; i < frequency; i++) {\n    result.push(current)\n  }\n  return result\n}, [])\n\nconst randomVariableAddress = ():CGPVariableAddress => random(DIMENSIONS.memory - 1)\n\nconst randomPalette = ():Palette => initArray(DIMENSIONS.colors, randomColorArray)\n\nconst randomNodeIndex = (layer:number):number => {\n  const firstNode = (layer + 1) * DIMENSIONS.layerSize\n  const result = Math.floor(Math.random() * DIMENSIONS.layerSize) + firstNode\n  return result\n}\n  \nfunction createRandomNode(layer:number):CGPNode {\n  const command = sample(weightedCommands)\n  if (!command) throw new Error(\"Invalid command\")\n  const last = layer === DIMENSIONS.layers - 1\n  const randomNext = ():CGPNodeAddress => last ? null : randomNodeIndex(layer)\n\n  return {\n    command,\n    next: [\n      randomNext(),\n      randomNext(),\n      randomNext(),\n    ],\n    variables: [\n      randomVariableAddress(),\n      randomVariableAddress(),\n      randomVariableAddress(),\n    ],    \n  }\n}\n\nexport function mutate(grid: CGPGrid):void {\n  // const { nodes } = grid\n  // const nodeIndex = Math.round(Math.random() * (nodes.length - 1))\n  // const node = nodes[nodeIndex]\n  \n  // const mutationKind = random(4)\n  \n  // switch (mutationKind) {\n  //   case 0:\n  //   case 1:\n  //     node.command = sample(weightedCommands) as CommandId\n  //     break;\n\n  //   case 2:\n  //   case 3:\n  //     node.next[random(2)] = randomNodeIndex(nodeIndex / DIMENSIONS.layerSize << 0)\n  //     break;\n\n  //   case 4:\n  //     node.variables[random(2)] = randomVariableAddress()\n  //     break\n\n  //   case 5: {\n  //     const { palette } = grid\n  //     const paletteIndex = random(palette.length - 1)\n  //     grid.palette[paletteIndex][random(2)] = random(DIMENSIONS.memory)\n  //     break\n  //   }\n  // }\n}\n\nfunction createRandomMemory():Array<VariableValue> {\n  const result = []\n  for (let i = 0; i < DIMENSIONS.memory; i++) { \n    result[i] = random(MEMORY_VALUE_MAX) / 2 << 0\n  }\n  return result\n}\n\nexport function createRandomGrid(): CGPGrid {\n  const nodes: Array<CGPNode> = new Array()\n  for (let layer = 0; layer < DIMENSIONS.layers; layer++) {\n    for (let i = 0; i < DIMENSIONS.layerSize; i++) {      \n      nodes[i + layer * DIMENSIONS.layerSize] = createRandomNode(layer)\n    }\n  }\n\n  const memory = createRandomMemory()\n  const palette = randomPalette()\n  return { nodes, memory, palette }\n}\n","import {\n  Color,\n  CHANNEL_ALPHA,\n  toCSSRGB,\n  dimmedGradient,\n} from './color'\nimport { MEMORY_VALUE_MAX } from './CGP'\nimport { State, BB } from './Parser'\n\nexport const MARGIN_LINE = 2\nexport const MARGIN_SPACE = 20\n\nexport function rect(\n  state:State,\n  fillColor:Color | null,\n  strokeColor:Color | null,\n  svg:any,\n  rounding:number | null,\n  gradientDirection: boolean\n):void {  \n  const { bb } = state\n\n  const margin = bb[2] - bb[0] > MARGIN_LINE * 2 && bb[3] - bb[1] > MARGIN_LINE * 2 ?\n    MARGIN_LINE : 0\n\n  const rectangle = svg.rect(\n    (bb[2] - bb[0] - margin * 2).toFixed(2),\n    (bb[3] - bb[1] - margin * 2).toFixed(2),\n  ).move(\n    (bb[0] + margin).toFixed(2),\n    (bb[1] + margin).toFixed(2)\n  ).attr({\n    fill: fillColor ? dimmedGradient(fillColor, svg, gradientDirection) : null,\n    stroke: strokeColor ? toCSSRGB(strokeColor) : null,\n    'fill-opacity': fillColor ? (fillColor[CHANNEL_ALPHA] / MEMORY_VALUE_MAX).toFixed(2) : 0,\n    // style: 'mix-blend-mode: multiply'\n  })\n\n  if (rounding) {\n    const smallestDimension = Math.min(bb[2] - bb[0], bb[3] - bb[1])\n    const roundingNormalized = rounding / MEMORY_VALUE_MAX * smallestDimension / 2\n    rectangle.radius(roundingNormalized)\n  }\n}\n\nexport function rhomb(bb:BB, color:Color, svg:any, gradientDirection:boolean, strokeOnly: boolean):BB {\n  const midX = (bb[2] - bb[0]) / 2 + bb[0]\n  const midY = (bb[3] - bb[1]) / 2 + bb[1]\n  const polygon = svg.polygon([\n    [midX, bb[1]],\n    [bb[2], midY],\n    [midX, bb[3]],\n    [bb[0], midY]\n  ])\n  polygon.attr({\n    fill: strokeOnly ? null : dimmedGradient(color, svg, gradientDirection),\n    stroke: toCSSRGB(color),\n    'fill-opacity': strokeOnly ? 0: (color[CHANNEL_ALPHA] / MEMORY_VALUE_MAX).toFixed(2),\n  })\n  \n  return [\n    (bb[2] - bb[0]) / 4 + bb[0],\n    (bb[3] - bb[1]) / 4 + bb[1],\n    (bb[2] - bb[0]) / 4 * 3 + bb[0],\n    (bb[3] - bb[1]) / 4 * 3 + bb[1],\n  ]\n}\n\nexport function triangle(state:State, fillColor:Color, svg:any, gradientDirection:boolean, shapeDirection:boolean):void {\n  const { bb } = state\n\n  const polygon = svg.polygon(\n    shapeDirection ? [\n      [bb[0], bb[1]],\n      [bb[2], bb[3]],\n      [bb[0], bb[3]]\n    ] : [\n      [bb[0], bb[1]],\n      [bb[2], bb[3]],\n      [bb[2], bb[1]]\n    ]\n  )\n  \n  polygon.attr({\n    fill: fillColor ? dimmedGradient(fillColor, svg, gradientDirection) : null,\n  })\n}\n\nexport function circle(state:State, color:Color, svg:any, showAsSquare:boolean, gradientDirection:boolean):void {  \n  const { bb } = state\n  const smallestDimension = Math.min(bb[2] - bb[0], bb[3] - bb[1])\n  const margin = bb[2] - bb[0] > MARGIN_LINE * 2 && bb[3] - bb[1] > MARGIN_LINE * 2 ?\n    MARGIN_LINE : 0\n  \n  const dim = smallestDimension - margin * 2\n  const object = showAsSquare ?\n    svg.rect(dim, dim) :\n    svg.circle(dim)\n  \n  object.move(\n    bb[0] + margin + (bb[2] - bb[0] - smallestDimension) / 2,\n    bb[1] + margin + (bb[3] - bb[1] - smallestDimension) / 2,\n  ).attr({\n    fill: dimmedGradient(color, svg, gradientDirection),\n    'fill-opacity': (color[CHANNEL_ALPHA] / MEMORY_VALUE_MAX).toFixed(2),\n  })\n}\n","import { \n  CGPNode,\n  AB,\n  FOR,\n  FILL,\n  SPLIT,\n  SHIFT,\n  CROOK,\n  MARGIN,\n  STROKE,\n  SWITCH,\n  SQUARE,\n  WINDOW,\n  CIRCLE,\n  LINES,\n  MULTIPLY,\n  TRIANGLE,\n  SAME_PLACE, \n  TERMINATE_WHEN,\n  DOTTED_STROKE,\n  INCREMENT_REGISTER_1,\n  INCREMENT_REGISTER_2,\n  INCREMENT_REGISTER_3,\n  DECREMENT_REGISTER_1,\n  DECREMENT_REGISTER_2,\n  DECREMENT_REGISTER_3,\n} from './CGP'\n\nimport threeVerticalLines from './svg/3-vertical-lines.svg'\nimport stripes from './svg/stripes.svg'\nimport split from './svg/split.svg'\nimport stroke from './svg/stroke.svg'\nimport question from './svg/question.svg'\nimport crooked from './svg/crooked.svg'\nimport ab from './svg/ab.svg'\nimport margin from './svg/margin.svg'\nimport shift from './svg/shift.svg'\nimport forLoop from './svg/for.svg'\nimport plus1 from './svg/plus1.svg'\nimport plus2 from './svg/plus2.svg'\nimport plus3 from './svg/plus3.svg'\nimport min1 from './svg/min1.svg'\nimport min2 from './svg/min2.svg'\nimport min3 from './svg/min3.svg'\nimport fill from './svg/fill.svg'\n\nconst CharacterMapping = {\n  [AB] : ab,\n  [FOR] : forLoop,\n  [FILL] : fill,\n  [SPLIT] : split, //threeVerticalLines,\n  [CROOK] : crooked,\n  [LINES] : stripes,//'☰',\n  [SHIFT] : shift,\n  [MARGIN] : margin,\n  [STROKE] : stroke,\n  [SQUARE] : '▧',\n  [WINDOW] : '♦',\n  [SWITCH] : question,\n  [CIRCLE] : '●',\n  [TRIANGLE] : '▵',\n  [MULTIPLY] : '×',\n  [SAME_PLACE] : '↶',\n  [DOTTED_STROKE] : '⋯',\n  [TERMINATE_WHEN] : '†',\n  [INCREMENT_REGISTER_1] : plus1,\n  [DECREMENT_REGISTER_1] : min1,\n  [INCREMENT_REGISTER_2] : plus2,\n  [DECREMENT_REGISTER_2] : min2,\n  [INCREMENT_REGISTER_3] : plus3,\n  [DECREMENT_REGISTER_3] : min3,\n}\n\n// const CharacterMapping = {\n//   [AB] : '𝕬',\n//   [FOR] : '𝖂',\n//   [FILL] : '𝕻',\n//   [SPLIT] : '𝖅', //threeVerticalLines,\n//   [CROOK] : '𝕲',\n//   [LINES] : '𝕸',//'☰',\n//   [SHIFT] : '𝕱',\n//   [MARGIN] : '𝕵',\n//   [STROKE] : '𝕶', //'⛄', // '❍',\n//   [SQUARE] : '▧',\n//   [WINDOW] : '♦',\n//   [SWITCH] : '𝕾',\n//   [CIRCLE] : '●',\n//   [TRIANGLE] : '▵',\n//   [MULTIPLY] : '𝖝',\n//   [SAME_PLACE] : '↶',\n//   [DOTTED_STROKE] : '⋯',\n//   [TERMINATE_WHEN] : '†',\n//   [INCREMENT_REGISTER_1] : '𝖘',\n//   [DECREMENT_REGISTER_1] : '𝖑',\n//   [INCREMENT_REGISTER_2] : '𝖘',\n//   [DECREMENT_REGISTER_2] : '𝖑',\n//   [INCREMENT_REGISTER_3] : '𝖘',\n//   [DECREMENT_REGISTER_3] : '𝖑',\n// }\n\nexport default class CharacterNode {\n  static current:CharacterNode | null\n  private element:HTMLDivElement\n  private traversed:boolean\n  private _opacity:number = 0\n  \n  set opacity(value:number) {\n    this._opacity = value\n    this.element.style.opacity = `${this._opacity}`\n  }\n\n  fade() {\n    if (CharacterNode.current === this) return\n    const newOpacity = this._opacity * 0.9\n    if (this.traversed) {\n      this.opacity = Math.max(0.1, newOpacity)\n    } else {\n      this.opacity = Math.max(0, newOpacity)\n    }\n  }\n\n  touch() {\n    CharacterNode.current = this\n    this.opacity = 1\n    this.traversed = true\n  }\n\n  constructor(x:number, y:number, parent:HTMLDivElement, node:CGPNode) {\n    this.traversed = false\n    this.element = document.createElement('div')\n    const character = CharacterMapping[node.command]\n    if (character.length > 1) {\n      this.element.innerHTML = `<img src=${character} />`\n    } else {\n      this.element.innerHTML = character\n    }\n    this.element.className = 'node'\n    this.element.style.left = `${x}px`\n    this.element.style.top = `${y}px`\n    parent.appendChild(this.element)\n    this.opacity = this._opacity\n  }\n}\n\nexport type CharacterGrid = Array<CharacterNode>\n","import { sleep } from './utils'\nimport { Viewport } from './utils'\nimport {\n  AB,\n  FOR,\n  FILL,\n  SPLIT,\n  CROOK,\n  SHIFT,\n  LINES,\n  SQUARE,\n  WINDOW,\n  STROKE,\n  CIRCLE,\n  MARGIN,\n  SWITCH,\n  TRIANGLE,\n  MULTIPLY,\n  SAME_PLACE,\n  TERMINATE_WHEN,\n  MEMORY_VALUE_MAX,\n  INCREMENT_REGISTER_1,\n  DECREMENT_REGISTER_1,\n  INCREMENT_REGISTER_2,\n  DECREMENT_REGISTER_2,\n  INCREMENT_REGISTER_3,\n  DECREMENT_REGISTER_3,\n\n  CGPGrid,\n  CGPNodeAddress,\n  CGPNode,\n  CGPVariableAddresses,\n  CGPVariableAddress,\n  VariableValues,\n  VariableValue,\n} from './CGP'\n\nimport { Color, Channel, ChannelAddress, toCSSRGB } from './color'\nimport { rect, circle, triangle, MARGIN_SPACE, MARGIN_LINE, rhomb } from './canvas'\nimport { bound } from './utils'\nimport CharacterNode from './CharacterNode';\nexport type BB = [number, number, number, number] // bounding box\nexport type State = { // basically used by a stack\n  bb: BB,\n}\n\ntype DirectionHorizontal = string\ntype DirectionVertical = string\ntype Direction = DirectionHorizontal | DirectionVertical\n\nconst VERTICAL:DirectionVertical = 'vertical'\nconst HORIZONTAL:DirectionHorizontal = 'horizontal'\n\nconst value = (variables:VariableValues, index:number, max:number):number => \n  Math.round(variables[index] / MEMORY_VALUE_MAX * max)\n\nexport default class Parser {\n  aborted:boolean = false\n  svg:any = null\n  drawingSize:Viewport\n  grid:CGPGrid\n  onBeat: Function\n\n  constructor(grid: CGPGrid, svg:any, drawingSize:Viewport, onBeat:Function) {\n    this.grid = grid\n    this.svg = svg\n    this.drawingSize = drawingSize\n    this.onBeat = onBeat\n  }\n\n  lookupValues(variables:CGPVariableAddresses):VariableValues {\n    const { memory } = this.grid\n    return variables.map((address:CGPVariableAddress):VariableValue => memory[address]) as VariableValues\n  }\n\n  incrementMemory(node:CGPNode, amount:number, registerIndex:number) {\n    const { memory } = this.grid\n    const oldValue = memory[node.variables[registerIndex]]\n    const newValue = oldValue + amount * 4\n    memory[node.variables[registerIndex]] = bound(newValue, 0, MEMORY_VALUE_MAX)\n  }\n\n  currentColor(node:CGPNode, grid:CGPGrid):Color {\n    const { memory, palette } = grid\n    const paletteIndex = Math.round(memory[node.variables[0]] / MEMORY_VALUE_MAX * (palette.length - 1))\n    const colorPointer = palette[paletteIndex]\n    const result = colorPointer.map((channelAddress:ChannelAddress):Channel => memory[channelAddress] / MEMORY_VALUE_MAX * 255)\n    return result as Color\n  }\n  \n  async decodeSplit(variables:VariableValues, state:State, node:CGPNode, takeFirst:boolean):Promise<void> {\n    let direction:Direction | null = null\n    if (variables[0] < MEMORY_VALUE_MAX / 3) {\n      direction = HORIZONTAL\n    } else if (variables[0] < MEMORY_VALUE_MAX / 3 * 2) {\n      direction = VERTICAL\n    } else {\n      direction = state.bb[3] - state.bb[1] > state.bb[2] - state.bb[0] ?\n        VERTICAL : HORIZONTAL\n    }\n    const count = value(variables, 1, 2) + 1\n    console.log(count)\n    const continueIndex = value(variables, 2, 3)\n    const traverseOrder = variables[1] > MEMORY_VALUE_MAX / 2\n    await this.split(direction, count, state, node, takeFirst, continueIndex, traverseOrder)\n  }\n\n  async split(\n    direction: Direction,\n    count:number,\n    state:State,\n    node:CGPNode,\n    takeFirst:boolean,\n    continueIndex:number | null,\n    traverseOrder:boolean\n  ) {\n    const size = (direction === HORIZONTAL) ?\n      (state.bb[2] - state.bb[0]) / count :\n      (state.bb[3] - state.bb[1]) / count\n  \n    for (let i = 0; i < count; i++) {\n      const index = traverseOrder ? i : count - i - 1\n      const bb:BB = (direction === HORIZONTAL) ? [\n        state.bb[0] + size * index, \n        state.bb[1], \n        state.bb[0] + size * (index + 1),\n        state.bb[3]\n      ] :\n      [\n        state.bb[0],\n        state.bb[1] + size * index, \n        state.bb[2], \n        state.bb[1] + size * (index + 1),\n      ]\n  \n      const newState:State = { ...state, bb }\n  \n      if (continueIndex !== null && index === continueIndex) {\n        await this.drawNode(node.next[1], newState)\n      } else {\n        await this.drawNode(node.next[takeFirst ? 0 : index], newState)\n      }\n    }     \n  }\n  async drawWindow(state:State, node:CGPNode, takeCenter:boolean, gradientDirection:boolean, strokeOnly:boolean) {\n    const centerBB:BB = rhomb(state.bb, this.currentColor(node, this.grid), this.svg, gradientDirection, strokeOnly)\n    const nextState:State = { ...state, bb: takeCenter || true ? centerBB : state.bb }\n    await this.drawNode(node.next[0], nextState)\n  }\n\n  drawLines(state:State, color:Color, variables:VariableValues) {\n    const MAX_DISTANCE = 25\n    const direction:Direction = variables[2] > variables[0] ? HORIZONTAL : VERTICAL\n    const lineDistance = variables[1] / MEMORY_VALUE_MAX * MAX_DISTANCE << 0\n    const { bb } = state\n    const count = direction === VERTICAL ? \n      (bb[3] - bb[1]) / lineDistance << 0 : \n      (bb[2] - bb[0]) / lineDistance << 0\n\n    for (let i = 0; i < count; i++) {\n      let line = null\n      if (direction === VERTICAL) {\n        const y = bb[1] + (i+0.5) * lineDistance\n        line = this.svg.line(\n          bb[0],\n          y,\n          bb[2],\n          y\n        )\n      } else {\n        const x = bb[0] + (i+0.5) * lineDistance\n        line = this.svg.line(\n          x,\n          bb[1],\n          x,\n          bb[3]\n        )\n      }\n\n      line \n        .stroke({ width: 0.1 })\n        .attr({ stroke: toCSSRGB(color) })\n    }\n  }\n\n  async margin(margin:number, node:CGPNode, state:State):Promise<void> {\n    const nextState:State = (\n      state.bb[0] + margin < state.bb[2] - margin &&\n      state.bb[1] + margin < state.bb[3] - margin\n    ) ?\n      {\n        ...state,\n        bb: [\n          state.bb[0] + margin,\n          state.bb[1] + margin,\n          state.bb[2] - margin,\n          state.bb[3] - margin\n        ]\n      }\n    : state\n  \n    await this.drawNode(node.next[0], nextState)\n  }\n\n  async drawNode(index: CGPNodeAddress, state:State):Promise<void> {\n    if (index === null || this.aborted) {\n      return\n    }\n    \n    await sleep(0)\n    const { nodes } = this.grid\n    const node = nodes[index]\n  \n    const { next, command } = node\n    const variables = this.lookupValues(node.variables)\n    \n    this.onBeat(index, node, variables)\n    switch (command) {\n      case SAME_PLACE:\n        await this.drawNode(next[0], state)\n        await this.drawNode(next[1], state)\n        break\n  \n      case SPLIT:\n        await this.decodeSplit(variables, state, node, false)\n        break\n  \n      case FOR:\n        await this.decodeSplit(variables, state, node, true)\n        break\n  \n      case SHIFT: {\n        const scale = variables[1] / MEMORY_VALUE_MAX\n        const move = variables[2] / MEMORY_VALUE_MAX\n        const { bb } = state\n  \n        const width = (bb[2] - bb[0])\n        const newWidth = width * scale\n        const emptySpace = width - newWidth\n        const offset = move * emptySpace\n        \n        const newState:State = {\n          ...state,\n          bb: [\n            bb[0] + offset,\n            bb[1],\n            bb[0] + newWidth + offset,\n            bb[3]\n          ]\n        } \n        await this.drawNode(next[0], newState)\n        break\n      }\n  \n      case AB: {\n        const { bb } = state\n        const width = (bb[2] - bb[0]) / 2\n        const height = (bb[3] - bb[1]) / 2\n  \n        const direction = variables[1] > 127\n        await this.drawNode(next[direction ? 0 : 1], { ...state, bb: [bb[0], bb[1], bb[0] + width, bb[1] + height] })\n        await this.drawNode(next[direction ? 1 : 0], { ...state, bb: [bb[0] + width, bb[1], bb[0] + width * 2, bb[1] + height] })\n        await this.drawNode(next[direction ? 1 : 0], { ...state, bb: [bb[0], bb[1] + height, bb[0] + width, bb[1] + height * 2] })\n        await this.drawNode(next[direction ? 0 : 1], { ...state, bb: [bb[0] + width, bb[1] + height, bb[0] + width * 2, bb[1] + height * 2] })\n  \n        break\n      }\n  \n      case SWITCH: {\n        const firstLargest = variables[0] > variables[1] ? 0 : 1\n        const firstLargestValue = variables[firstLargest]\n        const nextIndex = variables[2] > firstLargestValue ? 2 : firstLargest\n        await this.drawNode(next[nextIndex], state)\n        break\n      }\n  \n      case TERMINATE_WHEN:\n        if (variables[0] > variables[1]) {\n          await this.drawNode(next[1], state)\n        }\n        break\n  \n      case MARGIN:\n        await this.margin(MARGIN_SPACE, node, state)\n        break\n  \n      case MULTIPLY:\n        // multiplyMemory(node, memory)\n        await this.drawNode(next[0], state)\n        break\n\n      case INCREMENT_REGISTER_1:\n        this.incrementMemory(node, 1, 0)\n        await this.drawNode(next[0], state)\n        break\n  \n      case DECREMENT_REGISTER_1:\n        this.incrementMemory(node, -1, 0)\n        await this.drawNode(next[0], state)\n        break\n\n      case INCREMENT_REGISTER_2:\n        this.incrementMemory(node, 1, 1)\n        await this.drawNode(next[0], state)\n        break\n  \n      case DECREMENT_REGISTER_2:\n        this.incrementMemory(node, -1, 1)\n        await this.drawNode(next[0], state)\n        break\n\n      case INCREMENT_REGISTER_3:\n        this.incrementMemory(node, 1, 2)\n        await this.drawNode(next[0], state)\n        break\n  \n      case DECREMENT_REGISTER_3:\n      this.incrementMemory(node, -1, 2)\n        await this.drawNode(next[0], state)\n        break\n  \n      case LINES:\n        this.drawLines(state, this.currentColor(node, this.grid), variables)\n        await this.margin(MARGIN_LINE, node, state)\n        break\n\n      case FILL:\n        rect(state, this.currentColor(node, this.grid), null, this.svg, null, variables[1] > MEMORY_VALUE_MAX / 2)\n        await this.margin(MARGIN_LINE, node, state)\n        break\n  \n      case STROKE:\n        rect(state, null, this.currentColor(node, this.grid), this.svg, null, variables[1] > MEMORY_VALUE_MAX / 2)\n        await this.margin(MARGIN_LINE, node, state)\n        break\n        \n      case CIRCLE:\n        circle(state, this.currentColor(node, this.grid), this.svg, false, variables[1] > MEMORY_VALUE_MAX / 2)\n        await this.margin(MARGIN_LINE, node, state)\n        break\n  \n      case SQUARE:\n        circle(state, this.currentColor(node, this.grid), this.svg, true, variables[1] > MEMORY_VALUE_MAX / 2)\n        await this.margin(MARGIN_LINE, node, state)\n        break\n  \n      case CROOK:\n        rect(state, this.currentColor(node, this.grid), null, this.svg, variables[0], variables[1] > MEMORY_VALUE_MAX / 2)\n        await this.margin(MARGIN_LINE, node, state)\n        break\n        \n      case WINDOW:\n        await this.drawWindow(\n          state,\n          node,\n          variables[0] > MEMORY_VALUE_MAX / 2,\n          variables[1] > MEMORY_VALUE_MAX / 2,\n          variables[2] > MEMORY_VALUE_MAX / 2\n        )\n        break\n        \n      case TRIANGLE:\n        triangle(state, this.currentColor(node, this.grid), this.svg, variables[1] > 127, variables[2] > MEMORY_VALUE_MAX / 2)\n        await this.margin(MARGIN_LINE, node, state)\n        break\n  \n      default:\n        console.log(`not yet implemented: ${command}`)\n    }\n  }\n  \n  async draw():Promise<void> {\n    if (this.aborted) return\n    const initialState:State = {\n      bb: [0, 0, this.drawingSize.width, this.drawingSize.height],\n    }\n    \n    console.log('start...')\n    await this.drawNode(0, initialState)\n    CharacterNode.current = null\n    console.log('done!')    \n  }\n  \n  abort():void {\n    this.aborted = true\n  }  \n}\n","import { Color, toCSSRGB } from './color'\n\nexport default class ColorBullet {\n  private element: HTMLDivElement\n\n  constructor(x:number, container:HTMLDivElement) {\n    const element = document.createElement('div')\n    // element.innerHTML = '■' // '⬤'\n    element.style.left = `${x}px`\n    element.className = 'color'\n    container.appendChild(element)\n    this.element = element\n  }\n\n  set color(value:Color) {\n    this.element.style.backgroundColor = toCSSRGB(value)\n  }\n}","import { \n  CGPNodeAddress,\n  CGPNode,\n  VariableValues,\n  DIMENSIONS,\n  CGPGrid,\n  MEMORY_VALUE_MAX,\n} from './CGP'\nimport ColorBullet from './ColorBullet'\nimport { viewport } from './utils'\nimport { ChannelAddress, Channel, Color } from './color'\nimport CharacterNode, { CharacterGrid } from './CharacterNode'\n\nconst NODE_WIDTH = 48\nconst NODE_HEIGHT = 29\n\nexport default class Graph {\n  private container: HTMLDivElement\n  private grid: CGPGrid\n  private characterGrid: CharacterGrid | null = null\n  private palette: Array<ColorBullet> = []\n  private intervalId: any\n\n  constructor(container:HTMLDivElement, grid:CGPGrid) {\n    this.container = container\n    this.grid = grid\n    this.draw()\n    \n    this.intervalId = setInterval(this.interval, 50)\n  }\n\n  release() {\n    clearInterval(this.intervalId)\n\n    while (this.container.firstChild) {\n      this.container.removeChild(this.container.firstChild);\n    }\n  }\n\n  updatePalette() {\n    const { memory } = this.grid\n    this.grid.palette.forEach((color, index) => {\n      const result:Color = color.map((channelAddress:ChannelAddress):Channel => memory[channelAddress] / MEMORY_VALUE_MAX * 255) as Color\n      this.palette[index].color = result\n    })\n  }\n\n  createPalette() {\n    const v = viewport()\n    const result:Array<ColorBullet> = []\n    const SPACING = 30\n    \n    const translate = (v.width - v.height - DIMENSIONS.colors * SPACING) / 2\n    for (let i = 0; i < DIMENSIONS.colors; i++) {\n      result[i] = new ColorBullet(i * SPACING + translate, this.container)\n    }\n    return result\n  }\n\n  draw() {\n    const v = viewport()\n    const dimensions = [\n      NODE_WIDTH * DIMENSIONS.layerSize,\n      NODE_HEIGHT * DIMENSIONS.layers\n    ]\n    const translate = [\n      ((v.width - v.height) - dimensions[0]) /2,\n      (v.height - dimensions[1]) /2,\n    ]\n    \n    this.characterGrid = this.grid.nodes.reduce((result:CharacterGrid, node:CGPNode, index:number):CharacterGrid => {\n      const x = index % DIMENSIONS.layerSize\n      const y = Math.floor(index / DIMENSIONS.layerSize)\n\n      if (y === 0 && x > 0) {\n        return result\n      }\n      \n      const left = index === 0\n        ? dimensions[0] / 2 + translate[0] - NODE_WIDTH / 2\n        : x * NODE_WIDTH + translate[0]\n\n      const top = y * NODE_HEIGHT + translate[1]\n      \n      result[index] = new CharacterNode(left, top, this.container, node)\n      return result\n    }, [])    \n    this.palette = this.createPalette()\n  } \n\n  interval = () => {\n    if (!this.characterGrid) return\n    for (let i = 0; i < this.characterGrid.length; i++) {\n      const characterNode:CharacterNode = this.characterGrid[i]\n      if (!characterNode) continue\n      characterNode.fade()\n    }\n\n    this.updatePalette()\n  }\n\n  update = (index: CGPNodeAddress, node:CGPNode, variables: VariableValues) => {\n    if (index === null) return\n    if (!this.characterGrid) return\n    const characterNode:CharacterNode = this.characterGrid[index]\n    characterNode.touch()\n  }\n}\n","import React, { Component, DOMElement } from 'react'\nimport SVG from 'svg.js'\nimport './App.css'\nimport { createRandomGrid, CGPGrid, mutate, DIMENSIONS } from './CGP'\nimport Parser from './Parser'\nimport { viewport, sleep } from './utils'\nimport Graph from './Graph'\n\nexport default class App extends Component {\n  private containerElement: HTMLDivElement | null = null\n  private graphContainer: HTMLDivElement | null = null\n  private svg: any | null\n  private grid: CGPGrid = createRandomGrid()\n  private parser: Parser | null = null\n  private graph: Graph | null = null\n\n  shouldComponentUpdate() {\n    return false\n  }\n\n  async makeDrawing(grid:CGPGrid) {\n    const v = viewport()\n    if (!this.grid) return\n    const drawingSize = { width: v.height, height: v.height }\n    this.svg.size(v.height, v.height)\n    this.svg.clear()\n\n    if (this.parser) {\n      this.parser.abort()\n    }\n\n    if (!this.graph) throw new Error('Graph not initialised')\n    this.parser = new Parser(grid, this.svg, drawingSize, this.graph.update)\n    await this.parser.draw()\n    await sleep(5000)\n    this.refresh()\n  }\n\n  run = (containerElement:any) => {\n    if (!containerElement || this.containerElement) return\n    this.containerElement = containerElement\n    this.svg = SVG(containerElement)\n    this.makeDrawing(this.grid)\n  }\n\n  mutate():void {\n    if (this.grid) {\n      for (let i = 0; i < 10; i++) {\n        mutate(this.grid)\n      }\n      this.makeDrawing(this.grid)\n    }\n  }\n\n  refresh() {\n    if (!this.graph) throw new Error(\"graph not initialzed\")\n    if (!this.graphContainer) throw new Error(\"graph container not defined\");\n    this.grid = createRandomGrid()\n    this.graph.release()\n    this.graph = new Graph(this.graphContainer, this.grid)\n    this.makeDrawing(this.grid)\n  }\n\n  handleKey = (e:KeyboardEvent) => {\n    switch (e.which) {\n      case 77: // Mutate\n        this.mutate()\n        break\n\n      case 83: // Save\n        this.download()\n        break\n      case 82: // r\n        this.refresh()\n        break\n      default:\n        console.log(e.which)\n    }\n  }\n\n  componentDidMount(){\n    document.addEventListener(\"keydown\", this.handleKey, false);\n  }\n  componentWillUnmount(){\n    document.removeEventListener(\"keydown\", this.handleKey, false);\n  }\n \n  download = () => {\n    if (!this.containerElement) return\n    const svgData = this.containerElement.innerHTML;\n    const svgBlob = new Blob([svgData], {type:\"image/svg+xml;charset=utf-8\"});\n    const svgUrl = URL.createObjectURL(svgBlob);\n    const downloadLink = document.createElement(\"a\");\n    downloadLink.href = svgUrl;\n    downloadLink.download = `cgp-${Date.now()}.svg`;\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n  }\n\n  initGraph = (container:HTMLDivElement) => {     \n    if (this.graph) return\n    this.graphContainer = container\n    this.graph = new Graph(this.graphContainer, this.grid)\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div id=\"network\" ref={this.initGraph}></div>\n        <div id=\"drawing\" ref={this.run}></div>\n      </div>\n    )\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}